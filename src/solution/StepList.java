
package solution;

import delta.Delta;
import delta.DeltaList;
import delta.DeltaMultiset;
import delta.DeltaProduct;
import delta.DeltaRec;
import delta.DeltaSet;
import delta.UnknownRest;
import similarity.Sim;

//This StepList is a list of Delta
//It is used to represent the difference between TypeLists, TypeSets, TypeMultisets and TypeMappings
public class StepList
{ private final Delta step;
  private final StepList rest;
  //Either this.step==null&&this.rest==null (Empty StepList)
  //Or this.step!=null && this.rest!=null
  public StepList(){ this.step=null; this.rest=null;}//Constructor for empty stepList.
  public StepList(Delta step, StepList rest){ this.step=step; this.rest=rest;}//Constructor for non-empty stepList.        
  
  public boolean isEmptyStepList(){ return this.step==null&&this.rest==null;}
  
  public Delta head()
  { if(!this.isEmptyStepList()){ return this.step;}
    else{ throw new RuntimeException("Empty stepList has no head element.");}
  }       
  public StepList rest()
  { if(!this.isEmptyStepList()) return this.rest;
    else return new StepList();
  }        
  
  @Override
  public String toString()
  { StringBuffer buf=new StringBuffer();
    buf.append("[");
    if(!isEmptyStepList()) dump(buf);
    buf.append("]");
    return buf.toString();
  }
  private void dump(StringBuffer buf)
  { buf.append(this.step);
    if (!rest.isEmptyStepList()){ buf.append(", "); this.rest.dump(buf);}
  }  
  
  //insert a Delta in front of this list of delta      
  public StepList insert(Delta d){ return new StepList(d,this);}
 
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  public double weight()
  { if(!this.isEmptyStepList()) return this.step.weight()+this.rest.weight();
    else return 0.0;
  }   
  /*Here should be a parameter whole_weight
   *
  */
  public Sim sim()
  { if(!this.isEmptyStepList()) 
    { Sim stepSim=this.step.sim();
      Sim restSim=this.rest.sim();
      double stepWeight=this.step.weight();
      double restWeight=this.rest.weight();
      double weight=stepWeight+restWeight;
      double lwb=((stepWeight*stepSim.lwb()+restWeight*restSim.lwb())/weight);
      double upb=((stepWeight*stepSim.upb()+restWeight*restSim.upb())/weight);
      // System.out.println("StepList sim=["+lwb+", "+upb+"]");
      return new Sim(lwb, upb);
    }
    else return new Sim(0.0,0.0);
  }        
  
  //A stepList is the constructor of DeltaList, DeltaSet, DeltaMultiset and DeltaMapping
  //Take the DeltaList for example, the constructor of DeltaList is: DeltaList(StepList stepList)
  //When the first partial solution candidate is a DeltaList, the stepList need to be refined.
  //This refine_StepList() method will be called at that time by refine() method in DeltaList class
  public ListOfStepList refine_StepList()
  { //When the inside stepList is a non-empty stepList
    if(!this.isEmptyStepList())
    { //If it is a Unknown structure, or a UnknownRest structure
      if(!this.step.sim().isComplete())
      { //If there is still some steps after, for example it is a Unknown structure
        //Refine this step and combine each of them to the rest steps
        // newStep1----+             
        //             |                   
        // newStep2----+----this.rest 
        //             |                   
        // newStep3----+                
        if(!this.rest.isEmptyStepList())
        { return this.rest.combine_StepList(this.step.refine());}
        //If there is no any step after
        else
        { if(!(this.step instanceof UnknownRest))
          { return this.rest.combine_StepList(this.step.refine());}  
          else{ return release(this.step.refine());}  
        }
      }
      //If it is a deletion or insertion
      //It will be kept as the first step in this stepList
      //and it will be added to be the first step of each stepList generated by this.rest.refine_StepList()
      //            +----restStepList1
      //            |
      //this.step---+----restStepList2
      //            |
      //            +----restStepList3
      else{ return extend_StepList(this.step, this.rest.refine_StepList());}
    }
    else return new ListOfStepList();  
  }
  //        +----stepList1
  //        |               return
  //delta---+----stepList2  ======> ListOfStepList [(delta:stepList1),(delta:stepList2),(delta:stepList3)]
  //        |
  //        +----stepList3
  public ListOfStepList extend_StepList(Delta delta, ListOfStepList listoflist)
  { if (!listoflist.isEmptyListOfStepList())
    { return extend_StepList(delta, listoflist.rest()).insert(listoflist.head().insert(delta));}  
    else{ return new ListOfStepList();} // It is only used to recursion structure when listoflist.rest() is empty
  }
  // cand1----+         
  //          |         return
  // cand2----+----this ======> ListOfStepList [(cand1:this),(cand2:this)(cand3:this)]
  //          |             
  // cand3----+         
  public ListOfStepList combine_StepList(CandidatesList cands)
  { if(!cands.isEmptyCandidatesList())
    { return combine_StepList(cands.restCands()).insert(new StepList(cands.fstDelta(),this));} 
    else{ return new ListOfStepList();}
  }
  
  //Take DeltaList for example, Similarly apply to DeltaSet and DeltaMultiset
  // cands=[ DeltaList(stepList1), DeltaList(stepList2), DeltaList(stepList3)]
  // =====> return [stepList1, stepList2, stepList3]
  public ListOfStepList release(CandidatesList cands)
  { if(!cands.isEmptyCandidatesList())
    { if (cands.fstDelta() instanceof DeltaList)
      { DeltaList d=(DeltaList)cands.fstDelta();
        return release(cands.restCands()).insert(d.getStepList());
      }
      else if(cands.fstDelta() instanceof DeltaSet)
      { DeltaSet d=(DeltaSet)cands.fstDelta();
        return release(cands.restCands()).insert(d.getStepList());
      }    
      else if(cands.fstDelta() instanceof DeltaMultiset)
      { DeltaMultiset d=(DeltaMultiset)cands.fstDelta();
        return release(cands.restCands()).insert(d.getStepList());
      }
      else if(cands.fstDelta() instanceof DeltaRec)
      { DeltaRec d =(DeltaRec) cands.fstDelta();
        return release(cands.restCands()).insert(d.getStepList());
      }      
      else{ throw new RuntimeException("This release method will apply to the DeltaList, DeltaSet, DeltaMultiset and DeltaRec.\n"+cands);}  
    }
    else{ return new ListOfStepList();}    
  } 
}
